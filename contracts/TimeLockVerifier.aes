contract ProofOfTimeLock =
   datatype event = NewTimeLocks(indexed int, string, hash)

   record state = { timeLocks : map(string, int, int, hash), next_id : int }

   stateful entrypoint init() = { timeLocks = {}, next_id = 0 }

   entrypoint lockExists(lockOwner: string) : bool =
      Map.member(lockOwner, state.timeLocks)

   stateful entrypoint verifyTimeLocks(lockSequence: hash) =
      require(!lockUnique(lockOwner, lockDifficulty, lockSequence), "TimeLock is already taken")
      signTimeLocks(lockOwner, lockDifficulty, lockSequence)
      signMultipleTimeLocks(lockOwner, lockDifficulty, lockRound, lockSequence)
   
   entrypoint signTimeLocks(lockOwner: string, lockDifficulty: string, lockSequence: hash) : hash =
      require(lockExists(lockOwner, lockDifficulty, lockSequence), "TimeLocks does not exist!")
      state.timeLocks[lockOwner, lockDifficulty, lockSequence]

   stateful function signMultipleTimeLocks(lockOwner: string, lockDifficulty: string, lockSequence: hash, lockRound: int) =
      put(state{timeLocks[Chain.timestamp] = lockSequence, next_id = (state.next_id + 1)})
      Chain.event(signTimeLocks(state.next_id, lockOwner, lockDifficulty, lockSequence, lockRound))
 
   function verifyTimeLocks(lockOwner : string) : hash =
      String.sha3(lockOwner)
      
